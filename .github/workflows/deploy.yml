name: Deploy Lambda Functions

on:
  push:
    branches:
      - main
    paths:
      - '**/*.py'
      - 'requirements.txt'
      - 'resorts_config.json'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

env:
  AWS_REGION: us-west-2

jobs:
  deploy:
    name: Build and Deploy Lambda Functions
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build API Lambda package
        run: |
          echo "ğŸ“¦ æ„å»º API Lambda éƒ¨ç½²åŒ…..."
          
          # å®‰è£…ä¾èµ–
          pip install -r requirements.txt -t package/
          
          # å¤åˆ¶ä»£ç æ–‡ä»¶
          cp *.py package/
          cp *.json package/
          cp -r collectors package/
          
          # åˆ›å»ºéƒ¨ç½²åŒ…
          cd package
          zip -r ../api-lambda.zip .
          cd ..
          
          echo "âœ… API Lambda åŒ…æ„å»ºå®Œæˆ"
          ls -lh api-lambda.zip

      - name: Build Collector Lambda package
        run: |
          echo "ğŸ“¦ æ„å»º Collector Lambda éƒ¨ç½²åŒ…..."
          
          # ç¡®ä¿ä½¿ç”¨æœ€æ–°çš„ monitor.py å’Œ monitor_html.py
          cp monitor.py monitor_html.py s3_uploader.py package/
          
          # ç¡®ä¿ collectors ç›®å½•åœ¨ package ä¸­
          ls -la package/ | grep collectors || echo "Warning: collectors not found"
          
          # åˆ›å»º collector handler
          cat > package/collector_handler.py << 'EOF'
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          """Lambda å‡½æ•° - é›ªåœºæ•°æ®é‡‡é›†ï¼ˆå«æ•°æ®è´¨é‡ç›‘æ§ï¼‰"""
          
          import json
          import sys
          import os
          from datetime import datetime
          
          sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
          
          from resort_manager import ResortDataManager
          from failure_tracker import CollectionFailureTracker
          from s3_uploader import S3ReportUploader
          from monitor import DataMonitor
          
          def lambda_handler(event, context):
              """Lambda å¤„ç†å‡½æ•°"""
              print(f"æ”¶åˆ°äº‹ä»¶: {json.dumps(event)}")
              start_time = datetime.now()
              limit = event.get('limit')
              resort_id = event.get('resort_id')
              uploader = S3ReportUploader()
              
              try:
                  manager = ResortDataManager(config_file='resorts_config.json')
                  failure_tracker = CollectionFailureTracker()
                  
                  # å•ä¸ªé›ªåœºé‡‡é›†
                  if resort_id:
                      resort_config = None
                      for r in manager.resorts:
                          if r.get('id') == resort_id:
                              resort_config = r
                              break
                      
                      if not resort_config:
                          return {'statusCode': 404, 'body': json.dumps({'error': f'Resort ID {resort_id} not found'})}
                      
                      print(f"é‡‡é›†å•ä¸ªé›ªåœº: {resort_config.get('name')}")
                      data = manager.collect_resort_data(resort_config)
                      
                      if data:
                          manager.save_data([data])
                          end_time = datetime.now()
                          monitor_data = run_data_quality_check(manager)
                          stats = {
                              'start_time': start_time, 
                              'end_time': end_time,
                              'total_resorts': 1, 
                              'success_count': 1, 
                              'fail_count': 0,
                              'failed_resorts': []
                          }
                          generate_and_upload_report(uploader, stats, monitor_data)
                          return {'statusCode': 200, 'body': json.dumps({'message': 'Data collected successfully', 'resort': resort_config.get('name')})}
                      else:
                          end_time = datetime.now()
                          stats = {
                              'start_time': start_time, 
                              'end_time': end_time,
                              'total_resorts': 1, 
                              'success_count': 0, 
                              'fail_count': 1,
                              'failed_resorts': [{'name': resort_config.get('name'), 'error': 'Collection failed'}]
                          }
                          generate_and_upload_report(uploader, stats, None)
                          return {'statusCode': 500, 'body': json.dumps({'error': 'Collection failed'})}
                  
                  # æ‰¹é‡é‡‡é›†
                  resorts_to_collect = [r for r in manager.resorts if r.get('enabled', False)]
                  if limit:
                      resorts_to_collect = resorts_to_collect[:limit]
                  
                  print(f"å¼€å§‹é‡‡é›† {len(resorts_to_collect)} ä¸ªé›ªåœºï¼ˆå¹¶å‘ï¼‰")
                  results = manager.collect_all(enabled_only=True, failure_tracker=failure_tracker, max_workers=10)
                  
                  print(f"âœ… é‡‡é›†å®Œæˆ: {len(results)}/{len(resorts_to_collect)}")
                  
                  if results:
                      manager.save_data(results)
                  
                  # æ‰§è¡Œæ•°æ®è´¨é‡ç›‘æ§
                  print("ğŸ“Š å¼€å§‹æ•°æ®è´¨é‡ç›‘æ§...")
                  monitor_data = run_data_quality_check(manager)
                  
                  end_time = datetime.now()
                  stats = {
                      'start_time': start_time, 'end_time': end_time,
                      'total_resorts': len(resorts_to_collect),
                      'success_count': len(results), 
                      'fail_count': len(failure_tracker.failures),
                      'failed_resorts': failure_tracker.failures
                  }
                  report_url = generate_and_upload_report(uploader, stats, monitor_data)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': f'Collected {len(results)} resorts successfully',
                          'total_resorts': len(resorts_to_collect),
                          'success_count': len(results), 
                          'fail_count': len(failure_tracker.failures),
                          'report_url': report_url
                      })
                  }
              except Exception as e:
                  print(f"âŒ é‡‡é›†å¤±è´¥: {e}")
                  import traceback
                  traceback.print_exc()
                  end_time = datetime.now()
                  stats = {
                      'start_time': start_time, 'end_time': end_time,
                      'total_resorts': 0, 'success_count': 0, 'fail_count': 1,
                      'failed_resorts': [{'name': 'System Error', 'error': str(e)}]
                  }
                  try:
                      generate_and_upload_report(uploader, stats, None)
                  except:
                      pass
                  return {'statusCode': 500, 'body': json.dumps({'error': str(e), 'errorType': type(e).__name__})}
          
          def run_data_quality_check(manager):
              """æ‰§è¡Œæ•°æ®è´¨é‡ç›‘æ§"""
              try:
                  # ä»æ•°æ®åº“è·å–æ‰€æœ‰é›ªåœºçš„æœ€æ–°æ•°æ®
                  print("ğŸ“Š ä»æ•°æ®åº“è¯»å–æœ€æ–°é›ªåœºæ•°æ®...")
                  all_resorts_data = manager.db_manager.get_all_resorts_data()
                  
                  # æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®
                  if not all_resorts_data or len(all_resorts_data) == 0:
                      print("âš ï¸ æ•°æ®åº“ä¸­æ²¡æœ‰é›ªåœºæ•°æ®ï¼Œæ— æ³•ç”Ÿæˆç›‘æ§æŠ¥å‘Š")
                      return None
                  
                  print(f"âœ… ä»æ•°æ®åº“è¯»å–åˆ° {len(all_resorts_data)} ä¸ªé›ªåœºæ•°æ®")
                  
                  # æ„é€ ç¬¦åˆ monitor.monitor_all() æœŸæœ›çš„æ ¼å¼
                  latest_data = {
                      'metadata': {
                          'timestamp': datetime.now().isoformat(),
                          'total_resorts': len(all_resorts_data)
                      },
                      'resorts': all_resorts_data
                  }
                  
                  # ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶
                  import tempfile
                  with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False, encoding='utf-8') as f:
                      json.dump(latest_data, f, ensure_ascii=False, indent=2)
                      temp_file = f.name
                  
                  # æ‰§è¡Œç›‘æ§
                  monitor = DataMonitor()
                  reports = monitor.monitor_all(temp_file)
                  
                  # åˆ é™¤ä¸´æ—¶æ–‡ä»¶
                  os.unlink(temp_file)
                  
                  if reports:
                      # å°† dataclass å¯¹è±¡è½¬æ¢ä¸ºå­—å…¸
                      from dataclasses import asdict
                      reports_dict = [asdict(r) for r in reports]
                      
                      # ç”Ÿæˆç›‘æ§æŠ¥å‘Šæ•°æ®
                      monitor_data = {
                          'summary': {
                              'total_resorts': len(reports_dict),
                              'status_counts': {
                                  'good': sum(1 for r in reports if r.overall_status == 'good'),
                                  'success': sum(1 for r in reports if r.overall_status == 'success'),
                                  'warning': sum(1 for r in reports if r.overall_status == 'warning'),
                                  'error': sum(1 for r in reports if r.overall_status == 'error')
                              }
                          },
                          'resorts': reports_dict
                      }
                      
                      # ä¿®æ­£çŠ¶æ€è®¡æ•°çš„é”®åï¼ˆæœ¬åœ° HTML ä½¿ç”¨ 'success' è€Œä¸æ˜¯ 'good'ï¼‰
                      monitor_data['summary']['success'] = monitor_data['summary']['status_counts'].get('good', 0) + monitor_data['summary']['status_counts'].get('success', 0)
                      monitor_data['summary']['warning'] = monitor_data['summary']['status_counts']['warning']
                      monitor_data['summary']['error'] = monitor_data['summary']['status_counts']['error']
                      
                      print(f"âœ… æ•°æ®è´¨é‡ç›‘æ§å®Œæˆ: {len(reports_dict)} ä¸ªé›ªåœº")
                      print(f"   æ­£å¸¸: {monitor_data['summary']['success']}, è­¦å‘Š: {monitor_data['summary']['warning']}, é”™è¯¯: {monitor_data['summary']['error']}")
                      return monitor_data
                  else:
                      print("âš ï¸ ç›‘æ§æœªè¿”å›æ•°æ®")
                      return None
              except Exception as e:
                  print(f"âš ï¸ æ•°æ®è´¨é‡ç›‘æ§å¤±è´¥: {e}")
                  import traceback
                  traceback.print_exc()
                  return None
          
          def generate_and_upload_report(uploader, stats, monitor_data):
              """ç”Ÿæˆå¹¶ä¸Šä¼ æŠ¥å‘Šï¼ˆä½¿ç”¨æœ¬åœ° monitor_html.py çš„é€»è¾‘ï¼‰"""
              try:
                  from monitor_html import generate_html_report as generate_monitor_html
                  import tempfile
                  
                  # è®¡ç®—è¿è¡Œæ—¶é•¿
                  duration_seconds = (stats['end_time'] - stats['start_time']).total_seconds()
                  
                  # æ„å»ºå®Œæ•´çš„ç›‘æ§æŠ¥å‘Šæ•°æ®ï¼ˆä¸æœ¬åœ° collect_data.py ä¸€è‡´ï¼‰
                  report_data = {
                      'timestamp': stats['start_time'].isoformat(),
                      'duration_seconds': duration_seconds,
                      'summary': {
                          'total_resorts': 0,
                          'success': 0,
                          'warning': 0,
                          'error': 0,
                          'collection_total': stats.get('total_resorts', 0),
                          'collection_success': stats.get('success_count', 0),
                          'collection_failed': stats.get('fail_count', 0)
                      },
                      'resorts': [],
                      'collection_failures': stats.get('failed_resorts', [])
                  }
                  
                  # å¡«å…… summary å’Œ resortsï¼ˆå¦‚æœæœ‰ç›‘æ§æ•°æ®ï¼‰
                  if monitor_data:
                      if 'summary' in monitor_data:
                          # åˆå¹¶ç›‘æ§æ•°æ®çš„ summary
                          report_data['summary']['total_resorts'] = monitor_data['summary'].get('total_resorts', 0)
                          report_data['summary']['success'] = monitor_data['summary'].get('success', 0)
                          report_data['summary']['warning'] = monitor_data['summary'].get('warning', 0)
                          report_data['summary']['error'] = monitor_data['summary'].get('error', 0)
                      if 'resorts' in monitor_data:
                          report_data['resorts'] = monitor_data['resorts']
                  
                  # å¦‚æœæ²¡æœ‰ç›‘æ§æ•°æ®ï¼ˆæ•°æ®åº“ä¸ºç©ºï¼‰ï¼Œç”¨é‡‡é›†å¤±è´¥ä¿¡æ¯å¡«å……
                  if not report_data['resorts'] and stats.get('failed_resorts'):
                      print("âš ï¸ æ•°æ®åº“ä¸­æ— æ•°æ®ï¼Œä½¿ç”¨é‡‡é›†å¤±è´¥ä¿¡æ¯ç”ŸæˆæŠ¥å‘Š")
                      # æ³¨æ„ï¼šcollection_failures å·²ç»åœ¨ä¸Šé¢æ·»åŠ äº†
                  
                  print(f"ğŸ“Š æŠ¥å‘Šæ•°æ®: {len(report_data.get('resorts', []))} ä¸ªé›ªåœº, {len(report_data.get('collection_failures', []))} ä¸ªå¤±è´¥, è¿è¡Œæ—¶é•¿: {int(duration_seconds)}ç§’")
                  
                  # ä¿å­˜ JSON åˆ°ä¸´æ—¶æ–‡ä»¶
                  with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False, encoding='utf-8') as json_file:
                      json.dump(report_data, json_file, ensure_ascii=False, indent=2)
                      json_path = json_file.name
                  
                  # ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ä½œä¸º HTML è¾“å‡º
                  html_path = json_path.replace('.json', '.html')
                  
                  # ä½¿ç”¨æœ¬åœ°çš„ generate_html_report å‡½æ•°ç”Ÿæˆ HTML
                  generate_monitor_html(json_path, html_path)
                  
                  # è¯»å–ç”Ÿæˆçš„ HTML
                  with open(html_path, 'r', encoding='utf-8') as f:
                      html_content = f.read()
                  
                  # åˆ é™¤ä¸´æ—¶æ–‡ä»¶
                  os.unlink(json_path)
                  os.unlink(html_path)
                  
                  # ä¸Šä¼ æŠ¥å‘Š
                  timestamp = stats['start_time'].strftime('%Y%m%d_%H%M%S')
                  filename = f"report_{timestamp}.html"
                  report_url = uploader.upload_report(html_content, filename)
                  print(f"âœ… æŠ¥å‘Šå·²ç”Ÿæˆ: {report_url}")
                  
                  # æ›´æ–°ç´¢å¼•
                  uploader.update_index()
                  print(f"âœ… ç´¢å¼•é¡µé¢å·²æ›´æ–°")
                  
                  return report_url
              except Exception as e:
                  print(f"âš ï¸  æŠ¥å‘Šç”Ÿæˆå¤±è´¥: {e}")
                  import traceback
                  traceback.print_exc()
                  return None
          EOF
          
          # åˆ›å»ºéƒ¨ç½²åŒ…
          cd package
          zip -r ../collector-lambda.zip .
          cd ..
          
          echo "âœ… Collector Lambda åŒ…æ„å»ºå®Œæˆ"
          ls -lh collector-lambda.zip
          
          # éªŒè¯åŒ…å†…å®¹
          unzip -l collector-lambda.zip | grep collectors || echo "Warning: collectors not in zip"

      - name: Deploy API Lambda
        run: |
          echo "ğŸš€ éƒ¨ç½² API Lambda å‡½æ•°..."
          
          aws lambda update-function-code \
            --function-name resort-data-api \
            --zip-file fileb://api-lambda.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… API Lambda éƒ¨ç½²æˆåŠŸ"

      - name: Deploy Collector Lambda
        run: |
          echo "ğŸš€ éƒ¨ç½² Collector Lambda å‡½æ•°..."
          
          aws lambda update-function-code \
            --function-name resort-data-collector \
            --zip-file fileb://collector-lambda.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Collector Lambda éƒ¨ç½²æˆåŠŸ"
          
          echo "â³ ç­‰å¾… Lambda æ›´æ–°å®Œæˆ..."
          aws lambda wait function-updated \
            --function-name resort-data-collector \
            --region ${{ env.AWS_REGION }} || true
          
          echo "ğŸ”§ æ›´æ–° Collector Lambda ç¯å¢ƒå˜é‡ (Open-Meteo API Key)..."
          
          # è·å–ç°æœ‰ç¯å¢ƒå˜é‡
          EXISTING_ENV=$(aws lambda get-function-configuration \
            --function-name resort-data-collector \
            --region ${{ env.AWS_REGION }} \
            --query 'Environment.Variables' \
            --output json)
          
          echo "ç°æœ‰ç¯å¢ƒå˜é‡: $EXISTING_ENV"
          
          # ä½¿ç”¨ jq æ·»åŠ  OPENMETEO_API_KEY
          UPDATED_ENV=$(echo "$EXISTING_ENV" | jq '. + {"OPENMETEO_API_KEY": "${{ secrets.OPENMETEO_API_KEY }}"}')
          
          echo "æ›´æ–°åçš„ç¯å¢ƒå˜é‡: $UPDATED_ENV"
          
          # å†™å…¥ä¸´æ—¶æ–‡ä»¶
          echo "{\"Variables\": $UPDATED_ENV}" > collector_env.json
          
          # æ›´æ–° Lambda é…ç½®
          aws lambda update-function-configuration \
            --function-name resort-data-collector \
            --environment file://collector_env.json \
            --region ${{ env.AWS_REGION }}
          
          rm collector_env.json
          
          echo "âœ… Collector Lambda ç¯å¢ƒå˜é‡æ›´æ–°å®Œæˆ"

      - name: Build Contact Collector Lambda
        run: |
          echo "ğŸ“¦ æ„å»º Contact Collector Lambda åŒ…..."
          
          # åˆ›å»ºä¸´æ—¶ç›®å½•
          mkdir -p package-contact
          
          # å¤åˆ¶åŸºç¡€ä»£ç æ–‡ä»¶
          cp config.py db_manager.py models.py normalizer.py failure_tracker.py package-contact/
          cp resorts_config.json package-contact/
          
          # å¤åˆ¶ collectors ç›®å½•
          cp -r collectors package-contact/
          
          # å®‰è£…ä¾èµ–
          pip install -r requirements.txt -t package-contact/ --upgrade
          
          # åˆ›å»º contact_collector_handler.py
          cat > package-contact/contact_collector_handler.py << 'EOF'
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          """Lambda å‡½æ•° - é›ªåœºè”ç³»ä¿¡æ¯é‡‡é›†"""
          
          import json
          import sys
          import os
          from datetime import datetime
          import traceback
          from concurrent.futures import ThreadPoolExecutor, as_completed
          import threading
          
          sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
          
          from collectors.google_places import GooglePlacesCollector
          from db_manager import DatabaseManager
          
          def lambda_handler(event, context):
              """Lambda å¤„ç†å‡½æ•°"""
              print(f"æ”¶åˆ°äº‹ä»¶: {json.dumps(event)}")
              start_time = datetime.now()
              
              limit = event.get('limit')
              resort_id = event.get('resort_id')
              
              try:
                  # åŠ è½½é…ç½®
                  with open('resorts_config.json', 'r', encoding='utf-8') as f:
                      config = json.load(f)
                  resorts = config.get('resorts', [])
                  
                  # åˆå§‹åŒ–æ•°æ®åº“ç®¡ç†å™¨
                  db_manager = DatabaseManager()
                  
                  # å•ä¸ªé›ªåœºé‡‡é›†
                  if resort_id:
                      resort_config = None
                      for r in resorts:
                          if r.get('id') == resort_id:
                              resort_config = r
                              break
                      
                      if not resort_config:
                          return {
                              'statusCode': 404,
                              'body': json.dumps({'error': f'Resort ID {resort_id} not found'})
                          }
                      
                      print(f"é‡‡é›†å•ä¸ªé›ªåœºè”ç³»ä¿¡æ¯: {resort_config.get('name')}")
                      
                      collector = GooglePlacesCollector(resort_config)
                      contact_info = collector.collect()
                      
                      if contact_info:
                          success = db_manager.save_contact_info(resort_id, contact_info)
                          if success:
                              return {
                                  'statusCode': 200,
                                  'body': json.dumps({
                                      'message': 'Contact info collected successfully',
                                      'resort': resort_config.get('name')
                                  })
                              }
                          else:
                              return {
                                  'statusCode': 500,
                                  'body': json.dumps({'error': 'Database save failed'})
                              }
                      else:
                          return {
                              'statusCode': 404,
                              'body': json.dumps({'error': 'Contact info not found'})
                          }
                  
                  # æ‰¹é‡é‡‡é›†
                  resorts_to_collect = [r for r in resorts if r.get('enabled', False)]
                  if limit:
                      resorts_to_collect = resorts_to_collect[:limit]
                  
                  print(f"å¼€å§‹é‡‡é›† {len(resorts_to_collect)} ä¸ªé›ªåœºçš„è”ç³»ä¿¡æ¯ï¼ˆå¹¶å‘ï¼‰")
                  
                  success_count = 0
                  fail_count = 0
                  failed_resorts = []
                  
                  print_lock = threading.Lock()
                  
                  def collect_single_resort(resort_config):
                      resort_name = resort_config.get('name')
                      resort_id = resort_config.get('id')
                      
                      try:
                          collector = GooglePlacesCollector(resort_config)
                          contact_info = collector.collect()
                          
                          if contact_info:
                              success = db_manager.save_contact_info(resort_id, contact_info)
                              if success:
                                  with print_lock:
                                      print(f"   âœ… {resort_name} - æˆåŠŸ")
                                  return (True, None)
                              else:
                                  with print_lock:
                                      print(f"   âŒ {resort_name} - æ•°æ®åº“ä¿å­˜å¤±è´¥")
                                  return (False, 'Database save failed')
                          else:
                              with print_lock:
                                  print(f"   âš ï¸  {resort_name} - æœªæ‰¾åˆ°è”ç³»ä¿¡æ¯")
                              return (False, 'Contact info not found')
                      except Exception as e:
                          error_msg = str(e)[:200]
                          with print_lock:
                              print(f"   âŒ {resort_name} - é”™è¯¯: {error_msg}")
                          return (False, error_msg)
                  
                  with ThreadPoolExecutor(max_workers=10) as executor:
                      future_to_resort = {
                          executor.submit(collect_single_resort, resort_config): resort_config
                          for resort_config in resorts_to_collect
                      }
                      
                      for future in as_completed(future_to_resort):
                          resort_config = future_to_resort[future]
                          success, error = future.result()
                          
                          if success:
                              success_count += 1
                          else:
                              fail_count += 1
                              failed_resorts.append({
                                  'name': resort_config.get('name'),
                                  'id': resort_config.get('id'),
                                  'error': error
                              })
                  
                  end_time = datetime.now()
                  duration = (end_time - start_time).total_seconds()
                  
                  print(f"âœ… é‡‡é›†å®Œæˆ: {success_count}/{len(resorts_to_collect)} æˆåŠŸ")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': f'Collected contact info for {success_count} resorts',
                          'total_resorts': len(resorts_to_collect),
                          'success_count': success_count,
                          'fail_count': fail_count,
                          'failed_resorts': failed_resorts,
                          'duration_seconds': int(duration)
                      })
                  }
              
              except Exception as e:
                  print(f"âŒ é‡‡é›†å¤±è´¥: {e}")
                  traceback.print_exc()
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': str(e),
                          'errorType': type(e).__name__
                      })
                  }
          EOF
          
          # åˆ›å»ºéƒ¨ç½²åŒ…
          cd package-contact
          zip -r ../contact-collector-lambda.zip .
          cd ..
          
          echo "âœ… Contact Collector Lambda åŒ…æ„å»ºå®Œæˆ"
          ls -lh contact-collector-lambda.zip

      - name: Deploy Contact Collector Lambda
        run: |
          echo "ğŸš€ éƒ¨ç½² Contact Collector Lambda å‡½æ•°..."
          
          aws lambda update-function-code \
            --function-name resort-data-contact-collector \
            --zip-file fileb://contact-collector-lambda.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Contact Collector Lambda éƒ¨ç½²æˆåŠŸ"
          
          echo "â³ ç­‰å¾… Lambda æ›´æ–°å®Œæˆ..."
          aws lambda wait function-updated \
            --function-name resort-data-contact-collector \
            --region ${{ env.AWS_REGION }} || true
          
          echo "ğŸ”§ æ›´æ–° Contact Collector Lambda ç¯å¢ƒå˜é‡ (Google Maps API Key)..."
          
          # è·å–ç°æœ‰ç¯å¢ƒå˜é‡
          EXISTING_ENV=$(aws lambda get-function-configuration \
            --function-name resort-data-contact-collector \
            --region ${{ env.AWS_REGION }} \
            --query 'Environment.Variables' \
            --output json)
          
          echo "ç°æœ‰ç¯å¢ƒå˜é‡: $EXISTING_ENV"
          
          # ä½¿ç”¨ jq æ·»åŠ  GOOGLE_MAPS_API_KEY
          UPDATED_ENV=$(echo "$EXISTING_ENV" | jq '. + {"GOOGLE_MAPS_API_KEY": "${{ secrets.GOOGLE_MAPS_API_KEY }}"}')
          
          echo "æ›´æ–°åçš„ç¯å¢ƒå˜é‡: $UPDATED_ENV"
          
          # å†™å…¥ä¸´æ—¶æ–‡ä»¶
          echo "{\"Variables\": $UPDATED_ENV}" > contact_env.json
          
          # æ›´æ–° Lambda é…ç½®
          aws lambda update-function-configuration \
            --function-name resort-data-contact-collector \
            --environment file://contact_env.json \
            --region ${{ env.AWS_REGION }}
          
          rm contact_env.json
          
          echo "âœ… Contact Collector Lambda ç¯å¢ƒå˜é‡æ›´æ–°å®Œæˆ"

      - name: Build Notification Handler Lambda
        run: |
          echo "ğŸ“¦ æ„å»º Notification Handler Lambda åŒ…..."
          
          # åˆ›å»ºä¸´æ—¶ç›®å½•
          mkdir -p package
          
          # å¤åˆ¶ä»£ç 
          cp notification_handler.py push_service.py package/
          
          # å®‰è£…ä¾èµ–
          pip install -r requirements.txt -t package/ --upgrade
          
          # åˆ›å»ºéƒ¨ç½²åŒ…
          cd package
          zip -r ../notification-handler.zip .
          cd ..
          
          echo "âœ… Notification Handler Lambda åŒ…æ„å»ºå®Œæˆ"
          ls -lh notification-handler.zip

      - name: Build Snow Checker Lambda
        run: |
          echo "ğŸ“¦ æ„å»º Snow Checker Lambda åŒ…..."
          
          # åˆ›å»ºä¸´æ—¶ç›®å½•
          mkdir -p package-snow
          
          # å¤åˆ¶ä»£ç 
          cp check_snow_and_notify.py push_service.py package-snow/
          
          # å®‰è£…ä¾èµ–
          pip install -r requirements.txt -t package-snow/ --upgrade
          
          # åˆ›å»ºéƒ¨ç½²åŒ…
          cd package-snow
          zip -r ../snow-checker.zip .
          cd ..
          
          echo "âœ… Snow Checker Lambda åŒ…æ„å»ºå®Œæˆ"
          ls -lh snow-checker.zip

      - name: Build SQS Notification Processor Lambda
        run: |
          echo "ğŸ“¦ æ„å»º SQS Notification Processor Lambda åŒ…..."
          
          # åˆ›å»ºä¸´æ—¶ç›®å½•
          mkdir -p package-sqs
          
          # å¤åˆ¶ä»£ç 
          cp sqs_notification_processor.py push_service.py package-sqs/
          
          # å®‰è£… Lambda ä¸“ç”¨ä¾èµ–
          pip install -r requirements-lambda.txt -t package-sqs/ --upgrade
          
          # åˆ›å»ºéƒ¨ç½²åŒ…
          cd package-sqs
          zip -r ../sqs-notification-processor.zip .
          cd ..
          
          echo "âœ… SQS Notification Processor Lambda åŒ…æ„å»ºå®Œæˆ"
          ls -lh sqs-notification-processor.zip

      - name: Deploy Notification Handler Lambda
        run: |
          echo "ğŸš€ éƒ¨ç½² Notification Handler Lambda å‡½æ•°..."
          
          aws lambda update-function-code \
            --function-name resort-data-notification-handler \
            --zip-file fileb://notification-handler.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Notification Handler Lambda éƒ¨ç½²æˆåŠŸ"

      - name: Deploy Snow Checker Lambda
        run: |
          echo "ğŸš€ éƒ¨ç½² Snow Checker Lambda å‡½æ•°..."
          
          aws lambda update-function-code \
            --function-name resort-data-snow-checker \
            --zip-file fileb://snow-checker.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Snow Checker Lambda éƒ¨ç½²æˆåŠŸ"
          echo "â³ ç­‰å¾… Lambda æ›´æ–°å®Œæˆ..."
          sleep 10

      - name: Deploy SQS Notification Processor Lambda
        run: |
          echo "ğŸš€ éƒ¨ç½² SQS Notification Processor Lambda å‡½æ•°..."
          
          aws lambda update-function-code \
            --function-name resort-data-sqs-notification-processor \
            --zip-file fileb://sqs-notification-processor.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… SQS Notification Processor Lambda éƒ¨ç½²æˆåŠŸ"

      - name: Update Lambda Environment Variables
        run: |
          echo "ğŸ”§ æ›´æ–° Lambda ç¯å¢ƒå˜é‡ï¼ˆFirebase é…ç½®ï¼‰..."
          
          # ç­‰å¾…æ‰€æœ‰ Lambda å‡½æ•°æ›´æ–°å®Œæˆ
          echo "â³ ç­‰å¾…æ‰€æœ‰ Lambda å‡½æ•°å°±ç»ª..."
          aws lambda wait function-updated \
            --function-name resort-data-notification-handler \
            --region ${{ env.AWS_REGION }} || true
          
          aws lambda wait function-updated \
            --function-name resort-data-snow-checker \
            --region ${{ env.AWS_REGION }} || true
          
          aws lambda wait function-updated \
            --function-name resort-data-sqs-notification-processor \
            --region ${{ env.AWS_REGION }} || true
          
          echo "âœ… æ‰€æœ‰ Lambda å‡½æ•°å·²å°±ç»ª"
          
          # æ›´æ–° Notification Handler ç¯å¢ƒå˜é‡
          echo "ğŸ”§ æ›´æ–° Notification Handler ç¯å¢ƒå˜é‡..."
          
          # ä½¿ç”¨ jq æ„å»º JSONï¼Œæ­£ç¡®å¤„ç†æ¢è¡Œç¬¦
          jq -n \
            --arg supabase_url "${{ secrets.SUPABASE_URL }}" \
            --arg supabase_key "${{ secrets.SUPABASE_SERVICE_KEY }}" \
            --arg firebase_project "${{ secrets.FIREBASE_PROJECT_ID }}" \
            --arg firebase_key_id "${{ secrets.FIREBASE_PRIVATE_KEY_ID }}" \
            --arg firebase_key "${{ secrets.FIREBASE_PRIVATE_KEY }}" \
            --arg firebase_email "${{ secrets.FIREBASE_CLIENT_EMAIL }}" \
            --arg firebase_client_id "${{ secrets.FIREBASE_CLIENT_ID }}" \
            '{
              Variables: {
                SUPABASE_URL: $supabase_url,
                SUPABASE_SERVICE_KEY: $supabase_key,
                FIREBASE_PROJECT_ID: $firebase_project,
                FIREBASE_PRIVATE_KEY_ID: $firebase_key_id,
                FIREBASE_PRIVATE_KEY: $firebase_key,
                FIREBASE_CLIENT_EMAIL: $firebase_email,
                FIREBASE_CLIENT_ID: $firebase_client_id
              }
            }' > env_handler_final.json
          
          aws lambda update-function-configuration \
            --function-name resort-data-notification-handler \
            --environment file://env_handler_final.json \
            --region ${{ env.AWS_REGION }}
          
          rm env_handler_final.json
          
          echo "âœ… Notification Handler ç¯å¢ƒå˜é‡æ›´æ–°å®Œæˆ"
          echo "â³ ç­‰å¾…æ›´æ–°å®Œæˆ..."
          sleep 5
          
          # æ›´æ–° Snow Checker ç¯å¢ƒå˜é‡
          echo "ğŸ”§ æ›´æ–° Snow Checker ç¯å¢ƒå˜é‡..."
          
          # ä½¿ç”¨ jq æ„å»º JSONï¼Œæ­£ç¡®å¤„ç†æ¢è¡Œç¬¦
          jq -n \
            --arg db_host "${{ secrets.DB_HOST }}" \
            --arg db_name "${{ secrets.DB_NAME }}" \
            --arg db_user "${{ secrets.DB_USER }}" \
            --arg db_password "${{ secrets.DB_PASSWORD }}" \
            --arg redis_host "${{ secrets.REDIS_HOST }}" \
            --arg redis_port "${{ secrets.REDIS_PORT }}" \
            --arg firebase_project "${{ secrets.FIREBASE_PROJECT_ID }}" \
            --arg firebase_key_id "${{ secrets.FIREBASE_PRIVATE_KEY_ID }}" \
            --arg firebase_key "${{ secrets.FIREBASE_PRIVATE_KEY }}" \
            --arg firebase_email "${{ secrets.FIREBASE_CLIENT_EMAIL }}" \
            --arg firebase_client_id "${{ secrets.FIREBASE_CLIENT_ID }}" \
            '{
              Variables: {
                DB_HOST: $db_host,
                DB_NAME: $db_name,
                DB_USER: $db_user,
                DB_PASSWORD: $db_password,
                REDIS_HOST: $redis_host,
                REDIS_PORT: $redis_port,
                FIREBASE_PROJECT_ID: $firebase_project,
                FIREBASE_PRIVATE_KEY_ID: $firebase_key_id,
                FIREBASE_PRIVATE_KEY: $firebase_key,
                FIREBASE_CLIENT_EMAIL: $firebase_email,
                FIREBASE_CLIENT_ID: $firebase_client_id
              }
            }' > env_snow_final.json
          
          aws lambda update-function-configuration \
            --function-name resort-data-snow-checker \
            --environment file://env_snow_final.json \
            --region ${{ env.AWS_REGION }}
          
          rm env_snow_final.json
          
          echo "âœ… Snow Checker ç¯å¢ƒå˜é‡æ›´æ–°å®Œæˆ"
          echo "â³ ç­‰å¾…æ›´æ–°å®Œæˆ..."
          sleep 5
          
          # æ›´æ–° SQS Notification Processor ç¯å¢ƒå˜é‡
          echo "ğŸ”§ æ›´æ–° SQS Notification Processor ç¯å¢ƒå˜é‡..."
          
          # ä½¿ç”¨ jq æ„å»º JSONï¼Œæ­£ç¡®å¤„ç†æ¢è¡Œç¬¦
          jq -n \
            --arg supabase_url "${{ secrets.SUPABASE_URL }}" \
            --arg supabase_key "${{ secrets.SUPABASE_SERVICE_KEY }}" \
            --arg firebase_project "${{ secrets.FIREBASE_PROJECT_ID }}" \
            --arg firebase_key_id "${{ secrets.FIREBASE_PRIVATE_KEY_ID }}" \
            --arg firebase_key "${{ secrets.FIREBASE_PRIVATE_KEY }}" \
            --arg firebase_email "${{ secrets.FIREBASE_CLIENT_EMAIL }}" \
            --arg firebase_client_id "${{ secrets.FIREBASE_CLIENT_ID }}" \
            '{
              Variables: {
                SUPABASE_URL: $supabase_url,
                SUPABASE_SERVICE_KEY: $supabase_key,
                FIREBASE_PROJECT_ID: $firebase_project,
                FIREBASE_PRIVATE_KEY_ID: $firebase_key_id,
                FIREBASE_PRIVATE_KEY: $firebase_key,
                FIREBASE_CLIENT_EMAIL: $firebase_email,
                FIREBASE_CLIENT_ID: $firebase_client_id
              }
            }' > env_final.json
          
          aws lambda update-function-configuration \
            --function-name resort-data-sqs-notification-processor \
            --environment file://env_final.json \
            --region ${{ env.AWS_REGION }}
          
          rm env_final.json
          
          echo "âœ… æ‰€æœ‰ç¯å¢ƒå˜é‡æ›´æ–°æˆåŠŸ"

      - name: Trigger Initial Data Collection
        run: |
          echo "ğŸ¯ è§¦å‘ä¸€æ¬¡æ•°æ®é‡‡é›†..."
          
          # ç­‰å¾… Collector Lambda æ›´æ–°å®Œæˆ
          aws lambda wait function-updated \
            --function-name resort-data-collector \
            --region ${{ env.AWS_REGION }} || true
          
          # è°ƒç”¨ Collector Lambda
          aws lambda invoke \
            --function-name resort-data-collector \
            --invocation-type Event \
            --region ${{ env.AWS_REGION }} \
            response.json
          
          echo "âœ… æ•°æ®é‡‡é›†ä»»åŠ¡å·²å¯åŠ¨ï¼ˆå¼‚æ­¥æ‰§è¡Œï¼‰"
          echo "ğŸ“Š æŸ¥çœ‹é‡‡é›†æ—¥å¿—:"
          echo "   AWS Console â†’ CloudWatch Logs â†’ /aws/lambda/resort-data-collector"

      - name: Deployment Summary
        run: |
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… Lambda å‡½æ•°éƒ¨ç½²å®Œæˆï¼"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“¡ API è®¿é—®åœ°å€:"
          echo "   https://api.steponsnow.com/api/resorts"
          echo ""
          echo "ğŸ¯ æ•°æ®é‡‡é›†:"
          echo "   âœ… éƒ¨ç½²åè‡ªåŠ¨è§¦å‘äº†ä¸€æ¬¡æ•°æ®é‡‡é›†"
          echo "   â° å®šæ—¶ä»»åŠ¡: æ¯3å°æ—¶è‡ªåŠ¨é‡‡é›†"
          echo ""
          echo "ğŸ”§ éªŒè¯éƒ¨ç½²:"
          echo "   curl https://api.steponsnow.com/api/status"
          echo ""
          echo "ğŸ“Š æŸ¥çœ‹æ—¥å¿—:"
          echo "   AWS Console â†’ CloudWatch Logs"
          echo "   - /aws/lambda/resort-data-api"
          echo "   - /aws/lambda/resort-data-collector"
          echo "   - /aws/lambda/resort-data-notification-handler"
          echo "   - /aws/lambda/resort-data-snow-checker"
          echo ""
          echo "ğŸ”” æ¨é€é€šçŸ¥:"
          echo "   - Notification Handler: æ¯åˆ†é’Ÿæ£€æŸ¥é˜Ÿåˆ—"
          echo "   - Snow Checker: æ¯å°æ—¶æ£€æŸ¥é™é›ª"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
